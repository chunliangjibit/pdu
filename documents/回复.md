你给出的两条确认非常关键，它们把“该怎么补”从一堆可能性收敛成了两条确定结论：

1) **\(n\) 是绝对摩尔数（mol/recipe unit）而非摩尔分数**  
→ 声速里凡是用到 \(c_v\) 的地方，一定要明确它是 **按质量的 \(c_v\)（J/kg/K）** 还是 **总热容 \(C_v\)（J/K）**，并用 recipe unit 的总质量把它们对应起来。

2) **你当前 get_sound_speed 用的 \(c_v\) 来自 `compute_internal_energy_jcz3`，而该函数包含 \(P\)-依赖 cage correction，但 \(A\) 没同步修正**  
→ 这会在“路径 B（AD 二阶导/组合导数）”里放大成噪声/尖峰，直接制造伪 sonic 或 \(a^2<0\) 的 NaN。

下面给你一套**参数化的 Patch A/B/C/D（v1 推荐配置）**，目标是：  
- 先把 **数值稳定性 + 热力学一致性**拉到能稳定跑 ZND；  
- 再逐步把“物理精细项（cage correction）”以一致方式加回来（如果确实需要）。

---

## 总体执行顺序（强烈建议按这个顺序）

1) **Patch C（声速只从 \(A\) 推导）**：立刻切断 “\(c_v\) 不一致” 这条噪声源。  
2) **Patch A（硬球项：\(\eta>1\) 的域外行为修复 + 全部 max/clip 平滑化）**：消除 \(\eta>1\) 导致的负排斥/机械不稳定 + 二阶导 kink。  
3) **Patch B（NASA 1000K 切换平滑）**：消除 \(T=1000\) K 附近的导数尖峰。  
4) **Patch D（ZND 步长回退/拒绝策略）**：避免“一个坏点评估把整条轨迹炸没”。

---

# Patch C（v1）：把声速改成“只从 \(A(V,T;n)\) 的导数”计算，并明确 \(c_v\) 的单位

你现有实现类似：
\[
a^2 = \left(\frac{\partial P}{\partial \rho}\right)_T + \frac{T}{\rho^2 c_v}\left(\frac{\partial P}{\partial T}\right)_\rho^2
\]
这公式没问题，问题在于你给进去的 \(c_v\) 不是从同一个 \(A\) 推导出来的。

### C-1) 推荐：在 `implicit_eos.py/get_sound_speed` 内部**完全不用** `compute_internal_energy_jcz3` 来算 \(c_v\)

对固定组成（frozen composition），固定 \(n\) 与 \(V,T\) 下：
- \(P = -\left(\dfrac{\partial A}{\partial V}\right)_T\)
- \(C_v = \left(\dfrac{\partial U}{\partial T}\right)_V = -T\left(\dfrac{\partial^2 A}{\partial T^2}\right)_V\)

注意这里的 \(C_v\) 是 **总热容（J/K）**，你声速公式里需要的是 **质量比热 \(c_v\)（J/kg/K）**：

\[
c_v = \frac{C_v}{m},\qquad m=\sum_i n_i\,MW_i
\]

### C-2) 直接可用的代码骨架（SI 内部自洽；你当前 cm³/mol 口径也兼容）

把下面作为你 `get_sound_speed` 的新实现（或并行实现用于对照），关键参数都写死为 v1 推荐值：

```python
import jax
import jax.numpy as jnp

def smooth_floor(x, xmin, w):
    # C1 光滑下界：>= xmin
    return xmin + jax.nn.softplus((x - xmin) / w) * w

def get_sound_speed_from_A(
    n, V_cm3, T,
    mw_g_per_mol,  # shape (nspecies,)
    helmholtz_fn,  # callable: A = helmholtz_fn(n, V_cm3, T)  returns J (total for recipe unit)
):
    # 冻结组成：避免任何“把平衡求解器当成可微模块”的链式污染
    n = jax.lax.stop_gradient(n)

    # 质量与密度（SI）
    m_kg = jnp.sum(n * mw_g_per_mol) * 1e-3         # g -> kg
    V_m3 = V_cm3 * 1e-6
    rho = m_kg / V_m3                               # kg/m^3

    # A(V,T)
    def A_of_VT(Vc, Tc):
        return helmholtz_fn(n, Vc, Tc)

    # 一阶/二阶导（对 V_cm3、T）
    dA_dV = jax.grad(A_of_VT, argnums=0)
    dA_dT = jax.grad(A_of_VT, argnums=1)

    d2A_dV2 = jax.grad(lambda Vc, Tc: dA_dV(Vc, Tc), argnums=0)
    d2A_dVdT = jax.grad(lambda Vc, Tc: dA_dV(Vc, Tc), argnums=1)
    d2A_dT2 = jax.grad(lambda Vc, Tc: dA_dT(Vc, Tc), argnums=1)

    A_V  = dA_dV(V_cm3, T)          # J/cm^3
    A_VV = d2A_dV2(V_cm3, T)        # J/cm^6
    A_VT = d2A_dVdT(V_cm3, T)       # J/(cm^3 K)
    A_TT = d2A_dT2(V_cm3, T)        # J/K^2

    # 压力与导数（SI）
    P = -A_V * 1e6                  # Pa
    dP_dT = -A_VT * 1e6             # Pa/K  (等价于 (∂P/∂T)_rho，因为 n 固定时 rho<->V)
    dP_dV = -A_VV * 1e12            # Pa/m^3  (∂P/∂V)_T

    # (∂P/∂rho)_T = (∂P/∂V)_T * dV/drho,  V = m/rho => dV/drho = -V/rho
    dP_drho_T = dP_dV * (-V_m3 / rho)  # Pa / (kg/m^3) = m^2/s^2

    # Cv_total = -T * A_TT  (J/K)
    Cv_total = -T * A_TT

    # 数值保护：Cv 必须正；用光滑 floor 避免 1/Cv 爆炸
    Cv_min = 1e-6  # J/K，极小保护（不会改变正常区）
    Cv_total = smooth_floor(Cv_total, Cv_min, w=Cv_min)

    cv_mass = Cv_total / m_kg       # J/kg/K

    a2 = dP_drho_T + (T / (rho * rho * cv_mass)) * (dP_dT * dP_dT)  # m^2/s^2
    return a2, P, rho, cv_mass, dP_drho_T, dP_dT
```

### C-3) 你应该立刻做的对照验证（10 分钟就能定位主因）
在出现 NaN 的那一段 ZND 状态点上，**并行计算**：

- 旧实现 \(a^2_{\text{old}}\)（含 cage-corrected \(c_v\)）
- 新实现 \(a^2_{\text{A-only}}\)（上面函数）

如果你看到：
- \(a^2_{\text{old}}\) 乱跳/变负，而 \(a^2_{\text{A-only}}\) 平滑且为正  
那基本就确认：**伪 sonic 的主因就是热力学不一致 + kink 放大**（不是单位问题）。

---

# Patch A（v1）：硬球项 \(\eta\) 的“域外稳定化” + 所有 max/clip 的平滑参数

你已经知道最危险的点：\(\eta>1\) 时你当前表达式会走进“数学上还能算但物理上会变吸引”的区域，并且 `maximum()` 的折点对二阶导致命。

下面给出 **v1 推荐参数**：它尽量保留你原来“把发散封顶在 \(1-\eta=0.05\)”的意图，但彻底消除 \(\eta>1.33\) 负排斥、并提供可导的 barrier 把解推回物理域。

---

## A-1) 统一一个“光滑下界/上界”工具（全库复用）

```python
def smooth_floor(x, xmin, w):
    return xmin + jax.nn.softplus((x - xmin) / w) * w

def smooth_cap(x, xmax, w):
    return xmax - jax.nn.softplus((xmax - x) / w) * w
```

---

## A-2) 替换 `V_gas_eff = maximum(..., 1e-3)`（参数化）

你原来的 `1e-3 cm^3` 对 recipe unit 来说偏大，会在“气相几乎消失/固相占满”的情况下人为封顶导数。

**v1 推荐：**

- `V_MIN = 1e-6` cm³  
- `V_W   = 1e-6` cm³（平滑宽度）

```python
V_gas_raw = V_total - V_condensed_total
V_MIN = 1e-6
V_W   = 1e-6
V_gas_eff = smooth_floor(V_gas_raw, V_MIN, V_W)
```

> 为什么不是 1e-8？  
> 因为你一旦在 Newton 里走到负体积，\(P \sim nRT/V\) 会飙到 \(10^{18}\sim 10^{20}\) Pa 量级，虽然“理论上能把你推回来”，但非常容易在中间计算制造 Inf/NaN。`1e-6 cm^3` 是“足够小不影响正常物理、又足够大避免爆表”的折中起点。

---

## A-3) 硬球项改成：**CS（封顶在 \(\eta=0.95\)） + 软 barrier（\(\eta>0.95\)）**

### v1 推荐参数（你可以先直接用）
- \(\eta_{\text{cap}} = 0.95\)（与你原来 `max(1-eta, 0.05)` 等价的封顶点）
- `ETA_CAP_W = 0.005`（cap 的平滑宽度）
- `OVER_W   = 0.02`（barrier 起效宽度）
- `K_ETA    = 100.0`（barrier 强度）
- `p        = 2`（barrier 幂次；先用 2，别一上来用 4 把 Newton 变刚性地狱）

代码：

```python
eta_raw = B_total_gas / (4.0 * V_gas_eff)

ETA_CAP   = 0.95
ETA_CAP_W = 0.005

# CS 部分只在 <= 0.95 的“安全域”里用（避免域外分子变号）
eta_cs = smooth_cap(eta_raw, ETA_CAP, ETA_CAP_W)

one_minus = 1.0 - eta_cs  # >= 0.05（理论上）
# 如果你想更保险，也可以：one_minus = smooth_floor(one_minus, 0.05, 0.005)

f_cs = (4.0 * eta_cs - 3.0 * eta_cs * eta_cs) / (one_minus * one_minus)
A_cs = n_gas_total * R * T * f_cs

# 对 eta_raw 超过 0.95 的部分加 barrier：始终为正、光滑、可导
OVER_W = 0.02
over = jax.nn.softplus((eta_raw - ETA_CAP) / OVER_W) * OVER_W  # >= 0 (eta单位)

K_ETA = 100.0
p = 2
A_bar = n_gas_total * R * T * K_ETA * (over / OVER_W) ** p

A_excess_hs = A_cs + A_bar
```

### 这套参数会带来什么效果？
- \(\eta\le 0.95\)：你几乎得到原来的硬球行为（只是把 `maximum` kink 变成了平滑 cap）。  
- \(\eta>0.95\)：不会再出现 \(4\eta-3\eta^2<0\) 那种“硬球变吸引”的灾难；而且 barrier 会把平衡/迭代推回去。  
- 对声速：二阶导不再遇到 `maximum(1-eta, 0.05)` 的折点尖峰。

### 如果你发现 \(\eta\) 仍频繁跑到 1.05 以上（barrier 不够硬）
按这个顺序调参（一次只改一个）：
1. 把 `K_ETA: 100 -> 300`
2. 或把 `OVER_W: 0.02 -> 0.01`（更早更硬，但更可能让 Newton 刚性上升）
3. 或把 `p: 2 -> 3`（比直接跳到 4 温和）

---

## A-4) `clip(ratio, 0.4, 1.2)` 改为平滑 cap/floor（v1 参数）

推荐：
- `RATIO_W = 0.02`（无量纲）

```python
ratio = smooth_floor(ratio, 0.4, 0.02)
ratio = smooth_cap(ratio, 1.2, 0.02)
```

只要声速里对 \(T\) 求导会触到这里，这个改动就很值。

---

## A-5) 强烈建议：气相的理想气体项也用 `V_gas_eff`（否则“固相占体积”只在残余项里体现，会造成压力/导数不一致）

如果你当前理想项用了 `V_total`，建议改成：

- 用 `V_gas_eff` 进入所有气相体积依赖（log项、\(nRT\ln V\) 等）

这样压力导数在“固相占体积”情形才会整体一致。

---

# Patch B（v1）：NASA 1000K 切换由 `where` 改为 sigmoid 混合

### v1 推荐参数
- `T0 = 1000.0`
- `WIDTH = 30.0` K（如果你在 1000K 附近还看到尖峰，就加到 50K）

```python
def smooth_switch(T, T0=1000.0, width=30.0):
    return jax.nn.sigmoid((T - T0) / width)

w = smooth_switch(T, 1000.0, 30.0)
u = (1.0 - w) * u_low + w * u_high
s = (1.0 - w) * s_low + w * s_high
```

这一步对“伪 sonic”特别有效，因为 \(a^2\) 里必然出现 \(dP/dT\)、\(d^2A/dT^2\) 这类对温度切换极敏感的项。

---

# Patch D（v1）：ZND 积分加入“拒绝坏点 + 缩步重试”的硬规则（给出阈值）

你现在的症状是典型的：**某一步状态点评估炸了（NaN），积分器直接被污染**。解决方式不是继续硬怼 Newton，而是要在 ZND 外层加步长控制。

### v1 推荐拒绝条件（满足任意一条就 reject 并缩步）
在每步尝试计算完 EOS 后检查：

1. `isfinite`：\(P, a^2, c_v\) 任一非有限
2. 稳定性：`cv_mass <= 0`（或 `Cv_total <= 0`）
3. 机械性：`a2 <= 0`
4. packing：`eta_raw > 1.10`（这个阈值你可改成 1.05 更严）
5. 几何：`V_gas_raw < 0`（说明固相体积超过总容积，物理不可行，应让平衡解回退）

### v1 缩步策略
- 失败：`dz <- dz * 0.5`，同一步重试  
- 连续失败 10 次：直接退出并 dump 当步所有诊断量（见下）

### 建议你 dump 的最小诊断集（定位极快）
- `V_total, V_condensed_total, V_gas_raw, V_gas_eff`
- `n_gas_total, B_total_gas, eta_raw`
- `P, dP_drho_T, dP_dT, Cv_total, cv_mass, a2`
- 以及“ZND 层面”的 `u, T, rho`、反应进度变量

---

# 最关键的一条建议（结合你确认的“cage correction 不一致”）

在你把 ZND 跑稳定之前，**不要让 cage correction 参与任何需要导数的热力学量**（尤其是 \(c_v\)、声速、Jacobian）。推荐两种安全做法：

## 方案 1（最简单、最稳）：声速与任何导数项全部走 A-only；cage correction 只用于“输出能量”展示
- `get_sound_speed` 用 Patch C 的 A-only
- `compute_internal_energy_jcz3` 只用于非导数的 `u` 输出（或者用于后处理）

## 方案 2（折中）：保留 cage correction，但对它 `stop_gradient`
如果你非要让“修正后的 u”进入某些导数链（我不推荐），至少这样做：
- `corr_factor = stop_gradient(corr_factor)`  
这样它不会通过 \(P(V,T)\) 把二阶导搞炸。

---

# 你下一步怎么验证“补丁确实解决了伪 sonic”（建议按下面的 checklist）

1) 固定一个组成 \(n\)、温度 \(T\)，扫一条密度（或体积）线：  
   - 检查 \(P(V)\) 单调性：\((\partial P/\partial V)_T < 0\)  
   - 检查 \(a^2 > 0\) 且随密度变化平滑  
2) 在 NaN 曾出现的 ZND 前 10 个步长点：对照 old vs A-only 声速：  
   - 如果 A-only 平滑且为正，基本可以宣布“伪 sonic 主因已切断”  
3) 看 `eta_raw` 的分布：  
   - 目标是让 \(\eta\) **极少超过 1.0**，超过时也不会引入负排斥/尖峰

---

如果你愿意，我可以基于你当前代码的实际函数签名（`compute_total_helmholtz_energy`/`get_sound_speed` 的参数列表、`mw` 的数组形状、gas/solid mask 的定义方式）把上面这些 patch **改成与你仓库一致的“可直接粘贴的 diff 级别改动”**。你只需要贴两段函数头（签名）：

1) `compute_total_helmholtz_energy(...)` 的函数定义行  
2) `implicit_eos.py/get_sound_speed(...)` 的函数定义行（以及它现在怎么取 \(c_v\) 的 10 行核心代码）

你提供的这两段信息其实已经足够把“**低压 0.12 GPa**”的排查范围大幅收敛了：

- 你现在的 \(C_v\) 走的是 **Patch C（\(C_v=-T A_{TT}\)**）路径，这条路径**只影响声速/热容相关的项**；
- **压力 \(P\)**（以及点火能不能发生）主要由 **\(P = -\partial A/\partial V\)** 决定，和你贴出来的 \(C_v\) floor 基本无关。

所以：**低压仍然存在 ≠ \(C_v\) 还在算错**；它更像是 **\((\rho,n)\rightarrow (m,V)\)** 的“质量/体积/单位链”仍有错，或者 **固相 mask 把反应物从“可产生压力的体积依赖项”里屏蔽掉了**。

下面给你一个我认为最能“复制粘贴就立刻定位”的补丁：它做两件事

1) **把原子量（atomic_masses）统一成 kg/mol**（自动识别 g/mol vs kg/mol）  
2) **把输入密度 rho 统一成 kg/m³**（自动识别 g/cm³ vs kg/m³）  
然后用它们算出一致的 `m_kg`, `mw_avg_kg_per_mol`, `V_total_m3`，供 EOS 的 \(A(V,T)\) 求导链路使用。

> 这一步的价值在于：就算你的上层还在传 “rho=3.21”（g/cm³），或 atomic_masses 还在用 12.011 这种（g/mol），这里也会自动纠正成 SI，避免 10²–10³ 级误差继续渗透到压力上。

---

## 0) 你现在最需要的两个“判别打印”（先确认到底是哪类错）

在你 VN 初始点（step 0）打印这几个量，基本能一眼判定是不是“1000 倍单位错”或“molar vs total basis 错”：

- `rho_in`（原始输入）
- `rho_kg_m3`（统一后的）
- `n_tot`
- `m_kg`
- `mw_avg_kg_per_mol = m_kg/n_tot`
- `V_total_m3 = m_kg/rho_kg_m3`
- `V_molar_cm3 = (V_total_m3/n_tot)*1e6`

经验上，合理量级大致应满足：

- `mw_avg_kg_per_mol`：  
  - 若是未反应 HMX 单一组分：约 \(0.296\ \text{kg/mol}\)  
  - 若是产物混合物：常见在 \(0.02\sim 0.04\ \text{kg/mol}\) 一带（取决于机理）
- `V_molar_cm3`（凝聚相密度 \(3.2\ \text{g/cc}\) 量级）：通常是 \(10^1\sim 10^2\ \text{cm}^3/\text{mol}\)（例如 HMX 约 \( \sim 90\ \text{cm}^3/\text{mol}\)）

如果你看到：

- `mw_avg_kg_per_mol ≈ 296`：几乎可以断言**把 g/mol 当成 kg/mol 了**  
- `rho_kg_m3 ≈ 3.21`：几乎可以断言**把 g/cm³ 当成 kg/m³ 了**  
- `V_molar_cm3 ≈ 9e4`：也是典型 **rho 单位链错 1000 倍**  
- `n_tot` 巨大/巨小离谱：说明你 n 的“基准”（per kg / per mol / recipe unit）跟 EOS 预期不一致

---

## 1) Copy-paste 补丁：在 `pdu/thermo/implicit_eos.py` 里统一单位并把 `m_kg` 算死

> 你贴出来的 `get_sound_speed` 里已经有 `m_kg`，但**我猜你现在的 `m_kg` 很可能就是错在 atomic_masses 的单位**（常见：表里存的是 g/mol 数值，却当 kg/mol 用了）。

把下面这段 helper 加到 `implicit_eos.py`（靠近 import 之后、任意 jit 函数之前即可）：

```python
import jax
import jax.numpy as jnp
from jax import jit

# Debug 开关：需要时设 True，在 JIT 下也能打印
_DEBUG_EOS_UNITS = False


@jit
def _atomic_masses_to_kg_per_mol(atomic_masses):
    """
    Accept atomic masses in either:
      - g/mol  (typical magnitudes: 1..238)
      - kg/mol (typical magnitudes: 1e-3..0.238)
    Convert to kg/mol.
    """
    am = jnp.asarray(atomic_masses)
    # If max is > 0.5, it's almost certainly g/mol.
    return jnp.where(jnp.max(am) > 0.5, am * 1e-3, am)


@jit
def _rho_to_kg_per_m3(rho):
    """
    Accept rho in either:
      - g/cm3 (typical condensed: 0.5..20)
      - kg/m3 (typical condensed: 500..20000)
    Convert to kg/m3.
    """
    r = jnp.asarray(rho)
    return jnp.where(r > 50.0, r, r * 1000.0)


@jit
def _mixture_mass_and_mw_avg_kg_per_mol(n, atom_vec, atomic_masses):
    """
    n: mol (vector of species amounts)
    atom_vec: shape (n_species, n_atoms) mapping species -> atom counts
    atomic_masses: g/mol or kg/mol for atoms
    Returns:
      m_kg: total mass of mixture (kg)
      mw_avg_kg_per_mol: average molecular weight (kg/mol)
      mw_species_kg_per_mol: species molecular weights (kg/mol)
      n_tot: total moles (mol)
    """
    am_kg_per_mol = _atomic_masses_to_kg_per_mol(atomic_masses)
    mw_species_kg_per_mol = atom_vec @ am_kg_per_mol  # (n_species,)
    n = jnp.asarray(n)

    m_kg = jnp.dot(n, mw_species_kg_per_mol)
    n_tot = jnp.sum(n)
    mw_avg_kg_per_mol = m_kg / (n_tot + 1e-300)

    return m_kg, mw_avg_kg_per_mol, mw_species_kg_per_mol, n_tot
```

---

## 2) 在 `get_sound_speed` 里用这条单位链（并建议你同样改 `get_thermo_properties`）

你贴出来的 `get_sound_speed` 里只给了 \(C_v\) 片段，但关键是：**你要确保它在计算 \(A(V,T)\) 与导数时用的 `V_total` 是从“正确的 m_kg 与 rho_kg/m³”算出来的**。

在 `get_sound_speed` 函数体内（越靠前越好，至少在你构造 `V_total` / 调用 `compute_total_helmholtz_energy` 之前）加入/替换为：

```python
@jit
def get_sound_speed(rho, T, n, atom_vec, coeffs_low, coeffs_high, eos_params, atomic_masses):
    # --- Unit normalization & mixture mass ---
    rho_kg_m3 = _rho_to_kg_per_m3(rho)

    m_kg, mw_avg_kg_per_mol, mw_species_kg_per_mol, n_tot = (
        _mixture_mass_and_mw_avg_kg_per_mol(n, atom_vec, atomic_masses)
    )

    V_total_m3 = m_kg / rho_kg_m3  # m^3 (total volume for the given 'recipe unit')

    if _DEBUG_EOS_UNITS:
        V_molar_cm3 = (V_total_m3 / (n_tot + 1e-300)) * 1e6
        jax.debug.print(
            "EOS-UNITS: rho_in={:.6g}, rho_SI={:.6g} kg/m3, n_tot={:.6g} mol, "
            "m={:.6g} kg, mw_avg={:.6g} kg/mol, V_total={:.6g} m3, V_molar={:.6g} cm3/mol",
            rho, rho_kg_m3, n_tot, m_kg, mw_avg_kg_per_mol, V_total_m3, V_molar_cm3
        )

    # ------------------------------------------------------------
    # 接下来你原本怎么计算 A、A_TT、A_TV、A_VV、P 等就怎么继续，
    # 但请确保你传给 compute_total_helmholtz_energy 的 V_total
    # 用的是 V_total_m3，并且 mw_avg 传 mw_avg_kg_per_mol
    # ------------------------------------------------------------

    # 示例（你需要按你文件内已有的参数结构对齐 eos_params）：
    # A = compute_total_helmholtz_energy(
    #     n=n,
    #     V_total=V_total_m3,
    #     T=T,
    #     coeffs_low=coeffs_low,
    #     coeffs_high=coeffs_high,
    #     eps_vec=eos_params.eps_vec,
    #     r_star_vec=eos_params.r_star_vec,
    #     alpha_vec=eos_params.alpha_vec,
    #     lambda_vec=eos_params.lambda_vec,
    #     solid_mask=eos_params.solid_mask,
    #     solid_v0=eos_params.solid_v0,
    #     n_fixed_solids=eos_params.n_fixed_solids,
    #     v0_fixed_solids=eos_params.v0_fixed_solids,
    #     e_fixed_solids=eos_params.e_fixed_solids,
    #     r_star_rho_corr=eos_params.r_star_rho_corr,
    #     mw_avg=mw_avg_kg_per_mol,
    # )

    # ... 然后你现有的 Cv 逻辑可以保留 ...
```

> 重点不是“替换你的 Cv 逻辑”，而是：**把 `m_kg` / `rho` / `V_total` 的单位链变成不可出错的一条路**。  
> 你 ZND 初始化时那个 `P0=0.12 GPa` 很像就是在这条链上丢了一个 1e-3 或 1000。

---

## 3) 同样的修复一定要落到 “压力输出入口” 上（你 ZND 用的那个函数）

你现在 ZND 初始化打印 `P0` 用的是 `get_thermo_properties(rho, T, ...)`。  
如果 `get_sound_speed` 修了，但 `get_thermo_properties` 仍旧用旧的 mass/volume 链，ZND 还是会低压停滞。

所以你要把同一段逻辑复制到 `get_thermo_properties`（或任何计算 `V_total` 的地方）：

- 统一 `rho` 到 kg/m³
- 用 `atom_vec @ atomic_masses` 算 `mw_species`（确保 atomic_masses 是 kg/mol）
- 用 `m_kg` 和 `rho_kg_m3` 算 `V_total_m3`
- 调用 `compute_total_helmholtz_energy(..., V_total=V_total_m3, mw_avg=mw_avg_kg_per_mol)`

---

## 4) 还有一个“很可能你会撞到”的模型层问题：`solid_mask` 可能把反应物的压力贡献抹掉了

这一点我必须提前提醒你：就算单位全对，如果在 \( \lambda \approx 0 \) 时你的 `solid_mask` 把主要组分（反应物）当作“体积固定、能量不随 \(V\) 变”的固体处理，那么：

- \(A\) 对 \(V\) 的依赖会非常弱（甚至几乎为 0）
- 于是 \(P=-A_V\) 会非常小
- 反应速率 \(R \propto P^n\) 就会冻结  
这会产生**和你现在几乎一模一样的现象**（尤其是“VN 后感应区完全不动”）。

你可以用一个 10 秒的 A/B 测试判定是不是这个原因（无需改动力学）：

- 用同一个 \((\rho,T,n)\) 点，计算两次压力：
  1) 用原始 `solid_mask`
  2) 临时把 `solid_mask` 设为全 False（都当作可压缩流体项参与 EOS）

如果 (2) 的压力立刻跳到几十 GPa，而 (1) 还是 0.1 GPa 级别，那么问题**不是单位**，而是 **solid_mask 的物理语义/实现让 VN 处不产生压力**。

> 这类情况的“最小修复”通常不是加 spark，而是：  
> - VN/ZND 初始化时别把反应物当“不可压固体”，或者  
> - 给固相加一个可压缩的体积能项（哪怕是简化的 bulk modulus 模型）。

---
下面我把你给的 3 段信息（`compute_total_helmholtz_energy` 签名、`get_sound_speed` 签名、以及你目前基于 \(A_{TT}\) 的 \(c_v\) 与 \(a^2\) 计算）**直接落到 Patch E 的可实现方案**上：你现在已经具备了实现“守恒量投影 / DAE 化”的全部关键导数（至少 \(P_T\)、\(P_V\)、\(A_{TT}\)）——这正是解决“冷发散”的最短路径。

---

## 0. 你目前的 EOS 导数链已经足够：缺的只是把它用在 **(V,T) 投影求解** 上

你在 `implicit_eos.py` 里已经有：

- \(C_v = -T A_{TT}\)（你已实现）
- \(a^2 = (\partial P/\partial \rho)_T + \dfrac{T}{\rho^2 c_v}\,(\partial P/\partial T)_\rho^2\)（你已实现）

并且你有 `P_V_T`（实质是 \((\partial P/\partial V)_T\)）与 `P_T`（实质是 \((\partial P/\partial T)_V\)）。

这意味着你也可以做 **ZND 的“守恒量投影”**：

> 给定化学进度（或给定组分向量 \(n\)），用 **动量守恒 + 能量守恒** 直接解出该点的 \((V,T)\)，而不是显式积分 \(dT/d\xi\)。

这一步通常就能把你描述的“VN 后温度一路掉到 140 K 并触发 JCZ3 \(\eta\) 发散”的数值路径切断（因为那条路径本质来自端点刚性 + 显式温度积分的过冲）。

---

## 1. Patch E1（核心）：把 ZND 改成 “化学显式 + 热力学投影（Newton 解两条代数守恒式）”

### 1.1 选择未知量：推荐用 \((V_{\text{total}}, T)\)，而不是 \((\rho,T)\)

原因很直接：你的 EOS 原生接口就是 `compute_total_helmholtz_energy(n, V_total, T, ...)`。  
另外，你的声速推导里也在用 \(V_{\mathrm{total}}\)。

**定义：**

- 总质量 \(m_{\mathrm{kg}}\)：必须用你当前在 `implicit_eos.py` 里那套“由 \(n\) 与分子量/原子量”算出来的质量（保持一致）
- \(\rho = m_{\mathrm{kg}}/V_{\mathrm{total}}\)
- 质量通量（波系）\(J\)：上游已知  
  \[
  J = \rho_0 D
  \]
- 动量常数（Rayleigh 线常数）  
  \[
  \Pi = P_0 + \frac{J^2}{\rho_0}
  \]
- 能量常数（总焓 + 动能常数）  
  \[
  \mathcal{E} = e_0 + \frac{P_0}{\rho_0} + \frac{1}{2}\left(\frac{J}{\rho_0}\right)^2
  \]

> 这里 \(e\) 必须与 EOS 的能量定义一致（下面 1.3 会强调“热释放只算一次”的闭合）。

### 1.2 两个残差方程（每一步都解它们）

对给定组分 \(n\)（来自当前 \(\lambda\)）：

1) **动量守恒残差**
\[
R_1(V,T) = P(V,T,n) + \frac{J^2}{\rho(V)} - \Pi
\]
其中 \(\rho(V)=m_{\mathrm{kg}}/V\)，所以 \(\dfrac{J^2}{\rho}= \dfrac{J^2 V}{m_{\mathrm{kg}}}\)。

2) **能量守恒残差**
\[
R_2(V,T) = e(V,T,n) + \frac{P(V,T,n)}{\rho(V)} + \frac{1}{2}\left(\frac{J}{\rho(V)}\right)^2 - \mathcal{E}
\]
同样可写成：
\[
\frac{P}{\rho} = P\frac{V}{m_{\mathrm{kg}}},\qquad
\frac{1}{2}\left(\frac{J}{\rho}\right)^2 = \frac{1}{2}\frac{J^2 V^2}{m_{\mathrm{kg}}^2}
\]

### 1.3 如何从 Helmholtz \(A\) 得到 \(P\)、\(e\) 以及必要导数（完全用你已有的导数链）

只要 `compute_total_helmholtz_energy` 能提供（或你能从它得到）以下导数：

- \(A\)
- \(A_T = (\partial A/\partial T)_V\)
- \(A_{TT}\)
- \(A_V\)
- \(A_{VV}\)
- \(A_{VT}\)

就可以构造：

- 压力：
  \[
  P = -A_V
  \]
- 压力对温度导数（定容）：
  \[
  P_T = \left(\frac{\partial P}{\partial T}\right)_V = -A_{VT}
  \]
- 压力对体积导数（定温）：
  \[
  P_V = \left(\frac{\partial P}{\partial V}\right)_T = -A_{VV}
  \]
- 总内能（不是比内能）：
  \[
  U = A - T A_T
  \]
- 比内能：
  \[
  e = \frac{U}{m_{\mathrm{kg}}}
  \]
- 等容热容（总量）：
  \[
  C_v = \left(\frac{\partial U}{\partial T}\right)_V = -T A_{TT}
  \]
- 等容比热：
  \[
  c_v = \frac{C_v}{m_{\mathrm{kg}}}
  \]
- 内能对体积导数（定温），这个在 Newton 的 Jacobian 里会出现；用 Maxwell 关系可以写得很干净：
  \[
  \left(\frac{\partial U}{\partial V}\right)_T
  = A_V - T A_{VT}
  = -P + T P_T
  \]

> 你现在的 `get_sound_speed` 已经在用 \(A_{TT}\)、\(P_T\)、\(P_V\) 组合成 \(a^2\)；所以这些量在工程上你要么已经有了，要么只差把 `compute_total_helmholtz_energy` 的返回值扩展一下。

---

## 2. Newton 投影求解器：直接给你可粘贴的伪代码（按你当前变量风格）

### 2.1 建议用 \((\log V, \log T)\) 做未知量（强烈推荐）
原因：强制 \(V>0, T>0\)，同时 damping 更稳。

设：
\[
V = \exp(y_V),\quad T=\exp(y_T)
\]

Newton 时用链式法则：
\[
\frac{\partial R}{\partial y_V} = \frac{\partial R}{\partial V}\,V,\quad
\frac{\partial R}{\partial y_T} = \frac{\partial R}{\partial T}\,T
\]

### 2.2 Jacobian 的闭式表达（不需要数值差分）

先写 \(R_1, R_2\)：

- \(\rho = m_{\mathrm{kg}}/V\)
- \(R_1 = P + J^2 V/m_{\mathrm{kg}} - \Pi\)
- \(R_2 = (U/m_{\mathrm{kg}}) + P V/m_{\mathrm{kg}} + 0.5 J^2 V^2/m_{\mathrm{kg}}^2 - \mathcal{E}\)

对 \((V,T)\) 的偏导：

- \(\partial R_1/\partial V = P_V + J^2/m_{\mathrm{kg}}\)
- \(\partial R_1/\partial T = P_T\)

- \(\partial R_2/\partial V = \dfrac{1}{m_{\mathrm{kg}}}\left(\left(\frac{\partial U}{\partial V}\right)_T + P_V V + P\right) + \dfrac{J^2 V}{m_{\mathrm{kg}}^2}\)

但 \(\left(\frac{\partial U}{\partial V}\right)_T = -P + T P_T\)，代入后 **\(P\) 会抵消**，得到更稳定的形式：
\[
\frac{\partial R_2}{\partial V}
= \frac{T P_T + V P_V}{m_{\mathrm{kg}}} + \frac{J^2 V}{m_{\mathrm{kg}}^2}
\]

- \(\partial R_2/\partial T = \dfrac{1}{m_{\mathrm{kg}}}\left(\left(\frac{\partial U}{\partial T}\right)_V\right) + \dfrac{V}{m_{\mathrm{kg}}}P_T\)
即：
\[
\frac{\partial R_2}{\partial T} = c_v + \frac{P_T}{\rho}
\]
（因为 \(V/m_{\mathrm{kg}}=1/\rho\)）

这套 Jacobian 在端点刚性下比“直接积分 \(dT/d\xi\)”稳得多。

### 2.3 伪代码（Patch E1 的关键函数）

```python
def thermo_from_helmholtz(n, V_total, T, coeffs_low, coeffs_high,
                          eps_vec, r_star_vec, alpha_vec, lambda_vec,
                          solid_mask, solid_v0,
                          n_fixed_solids=0.0, v0_fixed_solids=10.0, e_fixed_solids=0.0,
                          r_star_rho_corr=0.0, mw_avg=1.0):
    # MUST return A and its derivatives; names below are illustrative
    A, A_T, A_TT, A_V, A_VV, A_VT = compute_total_helmholtz_energy(
        n, V_total, T, coeffs_low, coeffs_high,
        eps_vec, r_star_vec, alpha_vec, lambda_vec,
        solid_mask, solid_v0,
        n_fixed_solids=n_fixed_solids, v0_fixed_solids=v0_fixed_solids, e_fixed_solids=e_fixed_solids,
        r_star_rho_corr=r_star_rho_corr,
        mw_avg=mw_avg
    )

    P   = -A_V
    P_T = -A_VT
    P_V = -A_VV

    U_total = A - T * A_T
    Cv_total = -T * A_TT

    # mass (IMPORTANT: use the same mass computation as get_sound_speed uses)
    m_kg = mixture_mass_kg(n)  # implement consistent with implicit_eos.py

    e_mass = U_total / m_kg
    cv_mass = Cv_total / m_kg

    return P, e_mass, P_T, P_V, cv_mass, m_kg


def project_state_to_conservation(n, V_guess, T_guess,
                                  J, Pi, E,
                                  eos_args, newton_cfg):
    # Solve R1(V,T)=0, R2(V,T)=0
    yV = log(max(V_guess, newton_cfg.V_min))
    yT = log(max(T_guess, newton_cfg.T_min))

    for it in range(newton_cfg.max_it):
        V = exp(yV)
        T = exp(yT)

        P, e, P_T, P_V, cv_mass, m_kg = thermo_from_helmholtz(n, V, T, **eos_args)
        rho = m_kg / V

        R1 = P + (J*J)*V/m_kg - Pi
        R2 = e + P/rho + 0.5*(J/rho)**2 - E

        if norm2(R1, R2) < newton_cfg.tol:
            return V, T, rho, True

        # Jacobian in (V,T)
        dR1_dV = P_V + (J*J)/m_kg
        dR1_dT = P_T

        dR2_dV = (T*P_T + V*P_V)/m_kg + (J*J)*V/(m_kg*m_kg)
        dR2_dT = cv_mass + P_T/rho

        # Convert to Jacobian in (yV,yT)
        J11 = dR1_dV * V
        J12 = dR1_dT * T
        J21 = dR2_dV * V
        J22 = dR2_dT * T

        dyV, dyT = solve_2x2([[J11,J12],[J21,J22]], [-R1, -R2])

        # damping / line search
        step = 1.0
        for ls in range(newton_cfg.max_ls):
            yV_try = yV + step*dyV
            yT_try = yT + step*dyT
            V_try = exp(yV_try)
            T_try = exp(yT_try)

            if (V_try > newton_cfg.V_min) and (T_try > newton_cfg.T_min):
                # optional: check residual decreases
                yV, yT = yV_try, yT_try
                break
            step *= 0.5
        else:
            return None, None, None, False

    return None, None, None, False
```

---

## 3. Patch E3（你这次必须加）：用声速点作为终止条件，不要硬积分到 \(\lambda\to 1\)

你给的 `get_sound_speed` 接口已经满足：

```python
c = get_sound_speed(rho, T, n, atom_vec, coeffs_low, coeffs_high, eos_params, atomic_masses)
u = J / rho
if abs(u/c - 1.0) < sonic_tol:
    stop
```

**关键点：**
- 一旦 \(u \to c\)（sonic/CJ），ZND 的“梯度形式”天然奇异；继续逼近只会触发你现在看到的步长无限 shrink 与温度漂移。
- 如果你希望 \(\lambda=1\) 时刚好 sonic，那不是靠把积分跑到 1，而是要 **外层对 \(D\) 做 shooting/root find**（这就是“CJ 作为特征值”的那一套）。

---

## 4. 你现有声速实现里一个“隐性风险”：\(m_{\mathrm{kg}}\) 与 `mw_avg` 的一致性必须锁死

你在 `compute_total_helmholtz_energy` 里有一个参数 `mw_avg=1.0`。这很可疑：  
如果 EOS 内部某些项用 `mw_avg` 做了单位换算或理想气项，而 `get_sound_speed`/ZND 投影又用另一套方式算质量，那么会出现：

- \(e\) 的单位/尺度与 \(P/\rho\) 不在同一能量尺度；
- 守恒量残差会“被迫”通过把 \(T\) 拉到奇怪的低温/高温去满足；
- 这类错配会**极像你描述的冷发散**（特别是后段）。

**建议：**

- 方案 A（推荐）：在 EOS 层彻底不要 `mw_avg` 这种“外部平均分子量输入”，改成 EOS 内部从 `n` 和物种分子量直接算（或由上层统一算好并强制一致传入）。
- 方案 B（过渡）：显式把 `mw_avg` 设成由 `n` 计算得到的真实平均分子量，并保证 `get_sound_speed` 里用的质量与这里一致。

最小自检：在同一个 \(n,V,T\) 下，打印
- `m_kg (from thermo)`、
- `m_kg (from get_sound_speed internal)`  
必须一致到机器精度或至少相对误差 \(<10^{-10}\) 量级。

---

## 5. Patch E2（保险丝）：JCZ3 的低温域不要“钳制真实 T”，而是钳制 **直径模型输入/填充率**

你这次的信息里没贴 JCZ3 的实现细节，但你描述的症状非常明确：低温导致 \(d/r^\*\) 触发地板，\(\eta\) 飙升并最终让压力发散。

请按这个原则做保护：

- **不要 clamp 真实温度 \(T\)**（那会破坏守恒）
- clamp 的对象是：
  - \(d(T)\) 的输入温度（用 \(T_{\mathrm{eff}}=\mathrm{smooth\_clamp}(T, T_d^{\min}, \infty)\)）
  - 或者 \(\eta\) 本身（smooth ceiling）

这一步会让 EOS 在极端数值状态下不炸，但真正让你不再掉到 140 K 的，仍然是 E1/E3。

---


