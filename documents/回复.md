你给出的两条确认非常关键，它们把“该怎么补”从一堆可能性收敛成了两条确定结论：

1) **\(n\) 是绝对摩尔数（mol/recipe unit）而非摩尔分数**  
→ 声速里凡是用到 \(c_v\) 的地方，一定要明确它是 **按质量的 \(c_v\)（J/kg/K）** 还是 **总热容 \(C_v\)（J/K）**，并用 recipe unit 的总质量把它们对应起来。

2) **你当前 get_sound_speed 用的 \(c_v\) 来自 `compute_internal_energy_jcz3`，而该函数包含 \(P\)-依赖 cage correction，但 \(A\) 没同步修正**  
→ 这会在“路径 B（AD 二阶导/组合导数）”里放大成噪声/尖峰，直接制造伪 sonic 或 \(a^2<0\) 的 NaN。

下面给你一套**参数化的 Patch A/B/C/D（v1 推荐配置）**，目标是：  
- 先把 **数值稳定性 + 热力学一致性**拉到能稳定跑 ZND；  
- 再逐步把“物理精细项（cage correction）”以一致方式加回来（如果确实需要）。

---

## 总体执行顺序（强烈建议按这个顺序）

1) **Patch C（声速只从 \(A\) 推导）**：立刻切断 “\(c_v\) 不一致” 这条噪声源。  
2) **Patch A（硬球项：\(\eta>1\) 的域外行为修复 + 全部 max/clip 平滑化）**：消除 \(\eta>1\) 导致的负排斥/机械不稳定 + 二阶导 kink。  
3) **Patch B（NASA 1000K 切换平滑）**：消除 \(T=1000\) K 附近的导数尖峰。  
4) **Patch D（ZND 步长回退/拒绝策略）**：避免“一个坏点评估把整条轨迹炸没”。

---

# Patch C（v1）：把声速改成“只从 \(A(V,T;n)\) 的导数”计算，并明确 \(c_v\) 的单位

你现有实现类似：
\[
a^2 = \left(\frac{\partial P}{\partial \rho}\right)_T + \frac{T}{\rho^2 c_v}\left(\frac{\partial P}{\partial T}\right)_\rho^2
\]
这公式没问题，问题在于你给进去的 \(c_v\) 不是从同一个 \(A\) 推导出来的。

### C-1) 推荐：在 `implicit_eos.py/get_sound_speed` 内部**完全不用** `compute_internal_energy_jcz3` 来算 \(c_v\)

对固定组成（frozen composition），固定 \(n\) 与 \(V,T\) 下：
- \(P = -\left(\dfrac{\partial A}{\partial V}\right)_T\)
- \(C_v = \left(\dfrac{\partial U}{\partial T}\right)_V = -T\left(\dfrac{\partial^2 A}{\partial T^2}\right)_V\)

注意这里的 \(C_v\) 是 **总热容（J/K）**，你声速公式里需要的是 **质量比热 \(c_v\)（J/kg/K）**：

\[
c_v = \frac{C_v}{m},\qquad m=\sum_i n_i\,MW_i
\]

### C-2) 直接可用的代码骨架（SI 内部自洽；你当前 cm³/mol 口径也兼容）

把下面作为你 `get_sound_speed` 的新实现（或并行实现用于对照），关键参数都写死为 v1 推荐值：

```python
import jax
import jax.numpy as jnp

def smooth_floor(x, xmin, w):
    # C1 光滑下界：>= xmin
    return xmin + jax.nn.softplus((x - xmin) / w) * w

def get_sound_speed_from_A(
    n, V_cm3, T,
    mw_g_per_mol,  # shape (nspecies,)
    helmholtz_fn,  # callable: A = helmholtz_fn(n, V_cm3, T)  returns J (total for recipe unit)
):
    # 冻结组成：避免任何“把平衡求解器当成可微模块”的链式污染
    n = jax.lax.stop_gradient(n)

    # 质量与密度（SI）
    m_kg = jnp.sum(n * mw_g_per_mol) * 1e-3         # g -> kg
    V_m3 = V_cm3 * 1e-6
    rho = m_kg / V_m3                               # kg/m^3

    # A(V,T)
    def A_of_VT(Vc, Tc):
        return helmholtz_fn(n, Vc, Tc)

    # 一阶/二阶导（对 V_cm3、T）
    dA_dV = jax.grad(A_of_VT, argnums=0)
    dA_dT = jax.grad(A_of_VT, argnums=1)

    d2A_dV2 = jax.grad(lambda Vc, Tc: dA_dV(Vc, Tc), argnums=0)
    d2A_dVdT = jax.grad(lambda Vc, Tc: dA_dV(Vc, Tc), argnums=1)
    d2A_dT2 = jax.grad(lambda Vc, Tc: dA_dT(Vc, Tc), argnums=1)

    A_V  = dA_dV(V_cm3, T)          # J/cm^3
    A_VV = d2A_dV2(V_cm3, T)        # J/cm^6
    A_VT = d2A_dVdT(V_cm3, T)       # J/(cm^3 K)
    A_TT = d2A_dT2(V_cm3, T)        # J/K^2

    # 压力与导数（SI）
    P = -A_V * 1e6                  # Pa
    dP_dT = -A_VT * 1e6             # Pa/K  (等价于 (∂P/∂T)_rho，因为 n 固定时 rho<->V)
    dP_dV = -A_VV * 1e12            # Pa/m^3  (∂P/∂V)_T

    # (∂P/∂rho)_T = (∂P/∂V)_T * dV/drho,  V = m/rho => dV/drho = -V/rho
    dP_drho_T = dP_dV * (-V_m3 / rho)  # Pa / (kg/m^3) = m^2/s^2

    # Cv_total = -T * A_TT  (J/K)
    Cv_total = -T * A_TT

    # 数值保护：Cv 必须正；用光滑 floor 避免 1/Cv 爆炸
    Cv_min = 1e-6  # J/K，极小保护（不会改变正常区）
    Cv_total = smooth_floor(Cv_total, Cv_min, w=Cv_min)

    cv_mass = Cv_total / m_kg       # J/kg/K

    a2 = dP_drho_T + (T / (rho * rho * cv_mass)) * (dP_dT * dP_dT)  # m^2/s^2
    return a2, P, rho, cv_mass, dP_drho_T, dP_dT
```

### C-3) 你应该立刻做的对照验证（10 分钟就能定位主因）
在出现 NaN 的那一段 ZND 状态点上，**并行计算**：

- 旧实现 \(a^2_{\text{old}}\)（含 cage-corrected \(c_v\)）
- 新实现 \(a^2_{\text{A-only}}\)（上面函数）

如果你看到：
- \(a^2_{\text{old}}\) 乱跳/变负，而 \(a^2_{\text{A-only}}\) 平滑且为正  
那基本就确认：**伪 sonic 的主因就是热力学不一致 + kink 放大**（不是单位问题）。

---

# Patch A（v1）：硬球项 \(\eta\) 的“域外稳定化” + 所有 max/clip 的平滑参数

你已经知道最危险的点：\(\eta>1\) 时你当前表达式会走进“数学上还能算但物理上会变吸引”的区域，并且 `maximum()` 的折点对二阶导致命。

下面给出 **v1 推荐参数**：它尽量保留你原来“把发散封顶在 \(1-\eta=0.05\)”的意图，但彻底消除 \(\eta>1.33\) 负排斥、并提供可导的 barrier 把解推回物理域。

---

## A-1) 统一一个“光滑下界/上界”工具（全库复用）

```python
def smooth_floor(x, xmin, w):
    return xmin + jax.nn.softplus((x - xmin) / w) * w

def smooth_cap(x, xmax, w):
    return xmax - jax.nn.softplus((xmax - x) / w) * w
```

---

## A-2) 替换 `V_gas_eff = maximum(..., 1e-3)`（参数化）

你原来的 `1e-3 cm^3` 对 recipe unit 来说偏大，会在“气相几乎消失/固相占满”的情况下人为封顶导数。

**v1 推荐：**

- `V_MIN = 1e-6` cm³  
- `V_W   = 1e-6` cm³（平滑宽度）

```python
V_gas_raw = V_total - V_condensed_total
V_MIN = 1e-6
V_W   = 1e-6
V_gas_eff = smooth_floor(V_gas_raw, V_MIN, V_W)
```

> 为什么不是 1e-8？  
> 因为你一旦在 Newton 里走到负体积，\(P \sim nRT/V\) 会飙到 \(10^{18}\sim 10^{20}\) Pa 量级，虽然“理论上能把你推回来”，但非常容易在中间计算制造 Inf/NaN。`1e-6 cm^3` 是“足够小不影响正常物理、又足够大避免爆表”的折中起点。

---

## A-3) 硬球项改成：**CS（封顶在 \(\eta=0.95\)） + 软 barrier（\(\eta>0.95\)）**

### v1 推荐参数（你可以先直接用）
- \(\eta_{\text{cap}} = 0.95\)（与你原来 `max(1-eta, 0.05)` 等价的封顶点）
- `ETA_CAP_W = 0.005`（cap 的平滑宽度）
- `OVER_W   = 0.02`（barrier 起效宽度）
- `K_ETA    = 100.0`（barrier 强度）
- `p        = 2`（barrier 幂次；先用 2，别一上来用 4 把 Newton 变刚性地狱）

代码：

```python
eta_raw = B_total_gas / (4.0 * V_gas_eff)

ETA_CAP   = 0.95
ETA_CAP_W = 0.005

# CS 部分只在 <= 0.95 的“安全域”里用（避免域外分子变号）
eta_cs = smooth_cap(eta_raw, ETA_CAP, ETA_CAP_W)

one_minus = 1.0 - eta_cs  # >= 0.05（理论上）
# 如果你想更保险，也可以：one_minus = smooth_floor(one_minus, 0.05, 0.005)

f_cs = (4.0 * eta_cs - 3.0 * eta_cs * eta_cs) / (one_minus * one_minus)
A_cs = n_gas_total * R * T * f_cs

# 对 eta_raw 超过 0.95 的部分加 barrier：始终为正、光滑、可导
OVER_W = 0.02
over = jax.nn.softplus((eta_raw - ETA_CAP) / OVER_W) * OVER_W  # >= 0 (eta单位)

K_ETA = 100.0
p = 2
A_bar = n_gas_total * R * T * K_ETA * (over / OVER_W) ** p

A_excess_hs = A_cs + A_bar
```

### 这套参数会带来什么效果？
- \(\eta\le 0.95\)：你几乎得到原来的硬球行为（只是把 `maximum` kink 变成了平滑 cap）。  
- \(\eta>0.95\)：不会再出现 \(4\eta-3\eta^2<0\) 那种“硬球变吸引”的灾难；而且 barrier 会把平衡/迭代推回去。  
- 对声速：二阶导不再遇到 `maximum(1-eta, 0.05)` 的折点尖峰。

### 如果你发现 \(\eta\) 仍频繁跑到 1.05 以上（barrier 不够硬）
按这个顺序调参（一次只改一个）：
1. 把 `K_ETA: 100 -> 300`
2. 或把 `OVER_W: 0.02 -> 0.01`（更早更硬，但更可能让 Newton 刚性上升）
3. 或把 `p: 2 -> 3`（比直接跳到 4 温和）

---

## A-4) `clip(ratio, 0.4, 1.2)` 改为平滑 cap/floor（v1 参数）

推荐：
- `RATIO_W = 0.02`（无量纲）

```python
ratio = smooth_floor(ratio, 0.4, 0.02)
ratio = smooth_cap(ratio, 1.2, 0.02)
```

只要声速里对 \(T\) 求导会触到这里，这个改动就很值。

---

## A-5) 强烈建议：气相的理想气体项也用 `V_gas_eff`（否则“固相占体积”只在残余项里体现，会造成压力/导数不一致）

如果你当前理想项用了 `V_total`，建议改成：

- 用 `V_gas_eff` 进入所有气相体积依赖（log项、\(nRT\ln V\) 等）

这样压力导数在“固相占体积”情形才会整体一致。

---

# Patch B（v1）：NASA 1000K 切换由 `where` 改为 sigmoid 混合

### v1 推荐参数
- `T0 = 1000.0`
- `WIDTH = 30.0` K（如果你在 1000K 附近还看到尖峰，就加到 50K）

```python
def smooth_switch(T, T0=1000.0, width=30.0):
    return jax.nn.sigmoid((T - T0) / width)

w = smooth_switch(T, 1000.0, 30.0)
u = (1.0 - w) * u_low + w * u_high
s = (1.0 - w) * s_low + w * s_high
```

这一步对“伪 sonic”特别有效，因为 \(a^2\) 里必然出现 \(dP/dT\)、\(d^2A/dT^2\) 这类对温度切换极敏感的项。

---

# Patch D（v1）：ZND 积分加入“拒绝坏点 + 缩步重试”的硬规则（给出阈值）

你现在的症状是典型的：**某一步状态点评估炸了（NaN），积分器直接被污染**。解决方式不是继续硬怼 Newton，而是要在 ZND 外层加步长控制。

### v1 推荐拒绝条件（满足任意一条就 reject 并缩步）
在每步尝试计算完 EOS 后检查：

1. `isfinite`：\(P, a^2, c_v\) 任一非有限
2. 稳定性：`cv_mass <= 0`（或 `Cv_total <= 0`）
3. 机械性：`a2 <= 0`
4. packing：`eta_raw > 1.10`（这个阈值你可改成 1.05 更严）
5. 几何：`V_gas_raw < 0`（说明固相体积超过总容积，物理不可行，应让平衡解回退）

### v1 缩步策略
- 失败：`dz <- dz * 0.5`，同一步重试  
- 连续失败 10 次：直接退出并 dump 当步所有诊断量（见下）

### 建议你 dump 的最小诊断集（定位极快）
- `V_total, V_condensed_total, V_gas_raw, V_gas_eff`
- `n_gas_total, B_total_gas, eta_raw`
- `P, dP_drho_T, dP_dT, Cv_total, cv_mass, a2`
- 以及“ZND 层面”的 `u, T, rho`、反应进度变量

---

# 最关键的一条建议（结合你确认的“cage correction 不一致”）

在你把 ZND 跑稳定之前，**不要让 cage correction 参与任何需要导数的热力学量**（尤其是 \(c_v\)、声速、Jacobian）。推荐两种安全做法：

## 方案 1（最简单、最稳）：声速与任何导数项全部走 A-only；cage correction 只用于“输出能量”展示
- `get_sound_speed` 用 Patch C 的 A-only
- `compute_internal_energy_jcz3` 只用于非导数的 `u` 输出（或者用于后处理）

## 方案 2（折中）：保留 cage correction，但对它 `stop_gradient`
如果你非要让“修正后的 u”进入某些导数链（我不推荐），至少这样做：
- `corr_factor = stop_gradient(corr_factor)`  
这样它不会通过 \(P(V,T)\) 把二阶导搞炸。

---

# 你下一步怎么验证“补丁确实解决了伪 sonic”（建议按下面的 checklist）

1) 固定一个组成 \(n\)、温度 \(T\)，扫一条密度（或体积）线：  
   - 检查 \(P(V)\) 单调性：\((\partial P/\partial V)_T < 0\)  
   - 检查 \(a^2 > 0\) 且随密度变化平滑  
2) 在 NaN 曾出现的 ZND 前 10 个步长点：对照 old vs A-only 声速：  
   - 如果 A-only 平滑且为正，基本可以宣布“伪 sonic 主因已切断”  
3) 看 `eta_raw` 的分布：  
   - 目标是让 \(\eta\) **极少超过 1.0**，超过时也不会引入负排斥/尖峰

---

如果你愿意，我可以基于你当前代码的实际函数签名（`compute_total_helmholtz_energy`/`get_sound_speed` 的参数列表、`mw` 的数组形状、gas/solid mask 的定义方式）把上面这些 patch **改成与你仓库一致的“可直接粘贴的 diff 级别改动”**。你只需要贴两段函数头（签名）：

1) `compute_total_helmholtz_energy(...)` 的函数定义行  
2) `implicit_eos.py/get_sound_speed(...)` 的函数定义行（以及它现在怎么取 \(c_v\) 的 10 行核心代码）

你提供的这两段信息其实已经足够把“**低压 0.12 GPa**”的排查范围大幅收敛了：

- 你现在的 \(C_v\) 走的是 **Patch C（\(C_v=-T A_{TT}\)**）路径，这条路径**只影响声速/热容相关的项**；
- **压力 \(P\)**（以及点火能不能发生）主要由 **\(P = -\partial A/\partial V\)** 决定，和你贴出来的 \(C_v\) floor 基本无关。

所以：**低压仍然存在 ≠ \(C_v\) 还在算错**；它更像是 **\((\rho,n)\rightarrow (m,V)\)** 的“质量/体积/单位链”仍有错，或者 **固相 mask 把反应物从“可产生压力的体积依赖项”里屏蔽掉了**。

下面给你一个我认为最能“复制粘贴就立刻定位”的补丁：它做两件事

1) **把原子量（atomic_masses）统一成 kg/mol**（自动识别 g/mol vs kg/mol）  
2) **把输入密度 rho 统一成 kg/m³**（自动识别 g/cm³ vs kg/m³）  
然后用它们算出一致的 `m_kg`, `mw_avg_kg_per_mol`, `V_total_m3`，供 EOS 的 \(A(V,T)\) 求导链路使用。

> 这一步的价值在于：就算你的上层还在传 “rho=3.21”（g/cm³），或 atomic_masses 还在用 12.011 这种（g/mol），这里也会自动纠正成 SI，避免 10²–10³ 级误差继续渗透到压力上。

---

## 0) 你现在最需要的两个“判别打印”（先确认到底是哪类错）

在你 VN 初始点（step 0）打印这几个量，基本能一眼判定是不是“1000 倍单位错”或“molar vs total basis 错”：

- `rho_in`（原始输入）
- `rho_kg_m3`（统一后的）
- `n_tot`
- `m_kg`
- `mw_avg_kg_per_mol = m_kg/n_tot`
- `V_total_m3 = m_kg/rho_kg_m3`
- `V_molar_cm3 = (V_total_m3/n_tot)*1e6`

经验上，合理量级大致应满足：

- `mw_avg_kg_per_mol`：  
  - 若是未反应 HMX 单一组分：约 \(0.296\ \text{kg/mol}\)  
  - 若是产物混合物：常见在 \(0.02\sim 0.04\ \text{kg/mol}\) 一带（取决于机理）
- `V_molar_cm3`（凝聚相密度 \(3.2\ \text{g/cc}\) 量级）：通常是 \(10^1\sim 10^2\ \text{cm}^3/\text{mol}\)（例如 HMX 约 \( \sim 90\ \text{cm}^3/\text{mol}\)）

如果你看到：

- `mw_avg_kg_per_mol ≈ 296`：几乎可以断言**把 g/mol 当成 kg/mol 了**  
- `rho_kg_m3 ≈ 3.21`：几乎可以断言**把 g/cm³ 当成 kg/m³ 了**  
- `V_molar_cm3 ≈ 9e4`：也是典型 **rho 单位链错 1000 倍**  
- `n_tot` 巨大/巨小离谱：说明你 n 的“基准”（per kg / per mol / recipe unit）跟 EOS 预期不一致

---

## 1) Copy-paste 补丁：在 `pdu/thermo/implicit_eos.py` 里统一单位并把 `m_kg` 算死

> 你贴出来的 `get_sound_speed` 里已经有 `m_kg`，但**我猜你现在的 `m_kg` 很可能就是错在 atomic_masses 的单位**（常见：表里存的是 g/mol 数值，却当 kg/mol 用了）。

把下面这段 helper 加到 `implicit_eos.py`（靠近 import 之后、任意 jit 函数之前即可）：

```python
import jax
import jax.numpy as jnp
from jax import jit

# Debug 开关：需要时设 True，在 JIT 下也能打印
_DEBUG_EOS_UNITS = False


@jit
def _atomic_masses_to_kg_per_mol(atomic_masses):
    """
    Accept atomic masses in either:
      - g/mol  (typical magnitudes: 1..238)
      - kg/mol (typical magnitudes: 1e-3..0.238)
    Convert to kg/mol.
    """
    am = jnp.asarray(atomic_masses)
    # If max is > 0.5, it's almost certainly g/mol.
    return jnp.where(jnp.max(am) > 0.5, am * 1e-3, am)


@jit
def _rho_to_kg_per_m3(rho):
    """
    Accept rho in either:
      - g/cm3 (typical condensed: 0.5..20)
      - kg/m3 (typical condensed: 500..20000)
    Convert to kg/m3.
    """
    r = jnp.asarray(rho)
    return jnp.where(r > 50.0, r, r * 1000.0)


@jit
def _mixture_mass_and_mw_avg_kg_per_mol(n, atom_vec, atomic_masses):
    """
    n: mol (vector of species amounts)
    atom_vec: shape (n_species, n_atoms) mapping species -> atom counts
    atomic_masses: g/mol or kg/mol for atoms
    Returns:
      m_kg: total mass of mixture (kg)
      mw_avg_kg_per_mol: average molecular weight (kg/mol)
      mw_species_kg_per_mol: species molecular weights (kg/mol)
      n_tot: total moles (mol)
    """
    am_kg_per_mol = _atomic_masses_to_kg_per_mol(atomic_masses)
    mw_species_kg_per_mol = atom_vec @ am_kg_per_mol  # (n_species,)
    n = jnp.asarray(n)

    m_kg = jnp.dot(n, mw_species_kg_per_mol)
    n_tot = jnp.sum(n)
    mw_avg_kg_per_mol = m_kg / (n_tot + 1e-300)

    return m_kg, mw_avg_kg_per_mol, mw_species_kg_per_mol, n_tot
```

---

## 2) 在 `get_sound_speed` 里用这条单位链（并建议你同样改 `get_thermo_properties`）

你贴出来的 `get_sound_speed` 里只给了 \(C_v\) 片段，但关键是：**你要确保它在计算 \(A(V,T)\) 与导数时用的 `V_total` 是从“正确的 m_kg 与 rho_kg/m³”算出来的**。

在 `get_sound_speed` 函数体内（越靠前越好，至少在你构造 `V_total` / 调用 `compute_total_helmholtz_energy` 之前）加入/替换为：

```python
@jit
def get_sound_speed(rho, T, n, atom_vec, coeffs_low, coeffs_high, eos_params, atomic_masses):
    # --- Unit normalization & mixture mass ---
    rho_kg_m3 = _rho_to_kg_per_m3(rho)

    m_kg, mw_avg_kg_per_mol, mw_species_kg_per_mol, n_tot = (
        _mixture_mass_and_mw_avg_kg_per_mol(n, atom_vec, atomic_masses)
    )

    V_total_m3 = m_kg / rho_kg_m3  # m^3 (total volume for the given 'recipe unit')

    if _DEBUG_EOS_UNITS:
        V_molar_cm3 = (V_total_m3 / (n_tot + 1e-300)) * 1e6
        jax.debug.print(
            "EOS-UNITS: rho_in={:.6g}, rho_SI={:.6g} kg/m3, n_tot={:.6g} mol, "
            "m={:.6g} kg, mw_avg={:.6g} kg/mol, V_total={:.6g} m3, V_molar={:.6g} cm3/mol",
            rho, rho_kg_m3, n_tot, m_kg, mw_avg_kg_per_mol, V_total_m3, V_molar_cm3
        )

    # ------------------------------------------------------------
    # 接下来你原本怎么计算 A、A_TT、A_TV、A_VV、P 等就怎么继续，
    # 但请确保你传给 compute_total_helmholtz_energy 的 V_total
    # 用的是 V_total_m3，并且 mw_avg 传 mw_avg_kg_per_mol
    # ------------------------------------------------------------

    # 示例（你需要按你文件内已有的参数结构对齐 eos_params）：
    # A = compute_total_helmholtz_energy(
    #     n=n,
    #     V_total=V_total_m3,
    #     T=T,
    #     coeffs_low=coeffs_low,
    #     coeffs_high=coeffs_high,
    #     eps_vec=eos_params.eps_vec,
    #     r_star_vec=eos_params.r_star_vec,
    #     alpha_vec=eos_params.alpha_vec,
    #     lambda_vec=eos_params.lambda_vec,
    #     solid_mask=eos_params.solid_mask,
    #     solid_v0=eos_params.solid_v0,
    #     n_fixed_solids=eos_params.n_fixed_solids,
    #     v0_fixed_solids=eos_params.v0_fixed_solids,
    #     e_fixed_solids=eos_params.e_fixed_solids,
    #     r_star_rho_corr=eos_params.r_star_rho_corr,
    #     mw_avg=mw_avg_kg_per_mol,
    # )

    # ... 然后你现有的 Cv 逻辑可以保留 ...
```

> 重点不是“替换你的 Cv 逻辑”，而是：**把 `m_kg` / `rho` / `V_total` 的单位链变成不可出错的一条路**。  
> 你 ZND 初始化时那个 `P0=0.12 GPa` 很像就是在这条链上丢了一个 1e-3 或 1000。

---

## 3) 同样的修复一定要落到 “压力输出入口” 上（你 ZND 用的那个函数）

你现在 ZND 初始化打印 `P0` 用的是 `get_thermo_properties(rho, T, ...)`。  
如果 `get_sound_speed` 修了，但 `get_thermo_properties` 仍旧用旧的 mass/volume 链，ZND 还是会低压停滞。

所以你要把同一段逻辑复制到 `get_thermo_properties`（或任何计算 `V_total` 的地方）：

- 统一 `rho` 到 kg/m³
- 用 `atom_vec @ atomic_masses` 算 `mw_species`（确保 atomic_masses 是 kg/mol）
- 用 `m_kg` 和 `rho_kg_m3` 算 `V_total_m3`
- 调用 `compute_total_helmholtz_energy(..., V_total=V_total_m3, mw_avg=mw_avg_kg_per_mol)`

---

## 4) 还有一个“很可能你会撞到”的模型层问题：`solid_mask` 可能把反应物的压力贡献抹掉了

这一点我必须提前提醒你：就算单位全对，如果在 \( \lambda \approx 0 \) 时你的 `solid_mask` 把主要组分（反应物）当作“体积固定、能量不随 \(V\) 变”的固体处理，那么：

- \(A\) 对 \(V\) 的依赖会非常弱（甚至几乎为 0）
- 于是 \(P=-A_V\) 会非常小
- 反应速率 \(R \propto P^n\) 就会冻结  
这会产生**和你现在几乎一模一样的现象**（尤其是“VN 后感应区完全不动”）。

你可以用一个 10 秒的 A/B 测试判定是不是这个原因（无需改动力学）：

- 用同一个 \((\rho,T,n)\) 点，计算两次压力：
  1) 用原始 `solid_mask`
  2) 临时把 `solid_mask` 设为全 False（都当作可压缩流体项参与 EOS）

如果 (2) 的压力立刻跳到几十 GPa，而 (1) 还是 0.1 GPa 级别，那么问题**不是单位**，而是 **solid_mask 的物理语义/实现让 VN 处不产生压力**。

> 这类情况的“最小修复”通常不是加 spark，而是：  
> - VN/ZND 初始化时别把反应物当“不可压固体”，或者  
> - 给固相加一个可压缩的体积能项（哪怕是简化的 bulk modulus 模型）。

---

